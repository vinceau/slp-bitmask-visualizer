{"version":3,"sources":["lib/types.ts","lib/buttonsToBitmask.ts","store/reducers.ts","lib/bitmaskToButtons.ts","store/context.tsx","components/ControllerDisplay.tsx","lib/buttonsToController.tsx","components/BitmaskDisplay.tsx","components/OrderedButtonPreview.tsx","containers/ButtonMaskInput.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["InputBit","inputBitToName","Map","set","ButtonInput","D_LEFT","D_RIGHT","D_DOWN","D_UP","Z","R","L","A","B","X","Y","START","Types","generateInputBitmaskFromBit","buttons","reduce","a","b","generateInputBitmask","mappedButtons","map","mapInputToBits","button","get","Error","reducer","state","action","type","SetBitmask","payload","newState","mask","bitmask","inputs","Array","forEach","name","isButtonPressed","push","bitmaskToButtons","ToggleButton","newButtons","includes","filter","initialState","AppContext","createContext","dispatch","mainReducer","AppProvider","children","useReducer","Provider","value","ControllerDisplay","onClick","dl","dr","dd","du","z","r","l","x","y","start","buttonsToControllerState","hideAnalogSticks","MaskDisplay","title","BitmaskDisplay","css","toString","padStart","orderedInputs","OrderedButtonPreview","props","separator","i","join","ButtonMaskInput","useContext","useState","error","setError","onChange","isNaN","target","placeholder","hot","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.34ae1b80.chunk.js","sourcesContent":["import { ButtonInput } from \"react-gamecube\";\n\nexport enum InputBit {\n  D_LEFT = 0x0001,\n  D_RIGHT = 0x0002,\n  D_DOWN = 0x0004,\n  D_UP = 0x0008,\n  Z = 0x0010,\n  R = 0x0020,\n  L = 0x0040,\n  A = 0x0100,\n  B = 0x0200,\n  X = 0x0400,\n  Y = 0x0800,\n  START = 0x1000,\n}\n\nexport const inputBitToName = new Map<string, InputBit>()\n  .set(ButtonInput.D_LEFT, InputBit.D_LEFT)\n  .set(ButtonInput.D_RIGHT, InputBit.D_RIGHT)\n  .set(ButtonInput.D_DOWN, InputBit.D_DOWN)\n  .set(ButtonInput.D_UP, InputBit.D_UP)\n  .set(ButtonInput.Z, InputBit.Z)\n  .set(ButtonInput.R, InputBit.R)\n  .set(ButtonInput.L, InputBit.L)\n  .set(ButtonInput.A, InputBit.A)\n  .set(ButtonInput.B, InputBit.B)\n  .set(ButtonInput.X, InputBit.X)\n  .set(ButtonInput.Y, InputBit.Y)\n  .set(ButtonInput.START, InputBit.START);\n","import { InputBit, inputBitToName } from \"./types\";\n\nconst generateInputBitmaskFromBit = (...buttons: InputBit[]): number => {\n  return buttons.reduce((a, b) => a | b, 0);\n};\n\nexport const generateInputBitmask = (...buttons: string[]): number => {\n  const mappedButtons = buttons.map((b) => mapInputToBits(b));\n  return generateInputBitmaskFromBit(...mappedButtons);\n};\n\nconst mapInputToBits = (button: string): InputBit => {\n  const b = inputBitToName.get(button);\n  if (!b) {\n    throw new Error(`Unknown input: ${button}`);\n  }\n  return b;\n};\n","import { InitialStateType } from \"./types\";\nimport { bitmaskToButtons } from \"../lib/bitmaskToButtons\";\nimport { ButtonInput } from \"react-gamecube\";\nimport { generateInputBitmask } from \"../lib/buttonsToBitmask\";\n\ntype ActionMap<M extends { [index: string]: any }> = {\n  [Key in keyof M]: M[Key] extends undefined\n    ? {\n        type: Key;\n      }\n    : {\n        type: Key;\n        payload: M[Key];\n      };\n};\n\nexport enum Types {\n  SetBitmask = \"SET_BITMASK\",\n  ToggleButton = \"TOGGLE_BUTTON\",\n}\n\ntype ActionPayload = {\n  [Types.SetBitmask]: {\n    mask: number;\n  };\n  [Types.ToggleButton]: {\n    button: ButtonInput;\n  };\n};\n\nexport type ReducerActions = ActionMap<ActionPayload>[keyof ActionMap<ActionPayload>];\n\nexport const reducer = (state: InitialStateType, action: ReducerActions) => {\n  switch (action.type) {\n    case Types.SetBitmask:\n      const { payload } = action;\n      const newState = { ...state };\n      newState.mask = payload.mask;\n      newState.buttons = bitmaskToButtons(payload.mask);\n      return newState;\n    case Types.ToggleButton:\n      const { button } = action.payload;\n      let newButtons = [...state.buttons];\n      if (state.buttons.includes(button)) {\n        // remove button from state\n        newButtons = newButtons.filter((b) => b !== button);\n      } else {\n        // add button to state\n        newButtons.push(button);\n      }\n      return {\n        ...state,\n        buttons: newButtons,\n        mask: generateInputBitmask(...newButtons),\n      };\n    default:\n      return state;\n  }\n};\n","import { ButtonInput } from \"react-gamecube\";\nimport { InputBit, inputBitToName } from \"./types\";\n\nexport function isButtonPressed(bitmask: number, button: InputBit): boolean {\n  return (bitmask & button) === button;\n}\n\nexport function bitmaskToButtons(bitmask: number): ButtonInput[] {\n  const inputs = new Array<string>();\n  inputBitToName.forEach((mask, name) => {\n    if (isButtonPressed(bitmask, mask)) {\n      inputs.push(name);\n    }\n  });\n  return inputs as ButtonInput[];\n}\n","import React, { createContext, useReducer, Dispatch } from \"react\";\nimport { reducer, ReducerActions } from \"./reducers\";\nimport { InitialStateType } from \"./types\";\n\nconst initialState: InitialStateType = {\n  buttons: [],\n  mask: 0,\n};\n\nconst AppContext = createContext<{\n  state: InitialStateType;\n  dispatch: Dispatch<ReducerActions>;\n}>({\n  state: initialState,\n  dispatch: () => null,\n});\n\nconst mainReducer = (state: InitialStateType, action: ReducerActions) => reducer(state, action);\n\nconst AppProvider: React.FC = ({ children }) => {\n  const [state, dispatch] = useReducer(mainReducer, initialState);\n\n  return <AppContext.Provider value={{ state, dispatch }}>{children}</AppContext.Provider>;\n};\n\nexport { AppProvider, AppContext };\n","import React from \"react\";\nimport { ButtonInput, Controller } from \"react-gamecube\";\nimport { buttonsToControllerState } from \"../lib/buttonsToController\";\n\nexport interface ControllerDisplayProps {\n  buttons: ButtonInput[];\n  onClick?: (input: ButtonInput) => void;\n}\n\nexport const ControllerDisplay: React.FC<ControllerDisplayProps> = ({ buttons, onClick }) => {\n  const state = buttonsToControllerState(buttons);\n  return <Controller value={state} hideAnalogSticks={true} onClick={onClick} />;\n};\n","import { ButtonInput, ControllerInputState } from \"react-gamecube\";\n\nexport function buttonsToControllerState(inputs: ButtonInput[]): Partial<ControllerInputState> {\n  const newState: Partial<ControllerInputState> = {};\n  for (const inp of inputs) {\n    switch (inp) {\n      case ButtonInput.A:\n        newState.a = true;\n        break;\n      case ButtonInput.D_LEFT:\n        newState.dl = true;\n        break;\n      case ButtonInput.D_RIGHT:\n        newState.dr = true;\n        break;\n      case ButtonInput.D_DOWN:\n        newState.dd = true;\n        break;\n      case ButtonInput.D_UP:\n        newState.du = true;\n        break;\n      case ButtonInput.Z:\n        newState.z = true;\n        break;\n      case ButtonInput.R:\n        newState.r = true;\n        break;\n      case ButtonInput.L:\n        newState.l = true;\n        break;\n      case ButtonInput.B:\n        newState.b = true;\n        break;\n      case ButtonInput.X:\n        newState.x = true;\n        break;\n      case ButtonInput.Y:\n        newState.y = true;\n        break;\n      case ButtonInput.START:\n        newState.start = true;\n        break;\n    }\n  }\n  return newState;\n}\n","/** @jsx jsx */\nimport { css, jsx } from \"@emotion/core\";\nimport React from \"react\";\n\ninterface MaskDisplayProps {\n  title: string;\n}\nconst MaskDisplay: React.FC<MaskDisplayProps> = ({ title, children }) => {\n  return (\n    <div>\n      <div>{title}</div>\n      <div>{children}</div>\n    </div>\n  );\n};\n\nexport interface BitmaskDisplayProps {\n  mask: number;\n}\n\nexport const BitmaskDisplay: React.FC<BitmaskDisplayProps> = ({ mask }) => {\n  return (\n    <div\n      css={css`\n        display: grid;\n        grid-template-columns: 1fr 1fr 1fr;\n      `}\n    >\n      <MaskDisplay title=\"Binary\">0b{mask.toString(2).padStart(16, \"0\")}</MaskDisplay>\n      <MaskDisplay title=\"Decimal\">{mask.toString()}</MaskDisplay>\n      <MaskDisplay title=\"Hexadecimal\">0x{mask.toString(16)}</MaskDisplay>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { ButtonInput } from \"react-gamecube\";\n\nconst orderedInputs = [\n  ButtonInput.Z,\n  ButtonInput.L,\n  ButtonInput.R,\n  ButtonInput.A,\n  ButtonInput.B,\n  ButtonInput.X,\n  ButtonInput.Y,\n  ButtonInput.START,\n  ButtonInput.D_UP,\n  ButtonInput.D_DOWN,\n  ButtonInput.D_LEFT,\n  ButtonInput.D_RIGHT,\n];\n\nexport const OrderedButtonPreview: React.FC<{\n  value: string[];\n  separator?: string;\n}> = (props) => {\n  const separator = props.separator || \" + \";\n  return <span>{orderedInputs.filter((i) => props.value.includes(i)).join(separator)}</span>;\n};\n","/** @jsx jsx */\nimport { css, jsx } from \"@emotion/core\";\nimport React, { useContext, useState } from \"react\";\nimport { Types, AppContext } from \"../store\";\nimport { ControllerDisplay } from \"../components/ControllerDisplay\";\nimport { ButtonInput } from \"react-gamecube\";\nimport { BitmaskDisplay } from \"../components/BitmaskDisplay\";\nimport { OrderedButtonPreview } from \"../components/OrderedButtonPreview\";\n\nexport const ButtonMaskInput: React.FC = () => {\n  const { state, dispatch } = useContext(AppContext);\n  const [error, setError] = useState<string>(\"\");\n\n  const setBitmask = (mask: number) => {\n    dispatch({\n      type: Types.SetBitmask,\n      payload: {\n        mask,\n      },\n    });\n  };\n\n  const onChange = (value: string) => {\n    if (isNaN(+value)) {\n      setError(\"Invalid number\");\n    } else {\n      setError(\"\");\n      setBitmask(+value);\n    }\n  };\n\n  const onButtonClick = (button: ButtonInput): void => {\n    dispatch({\n      type: Types.ToggleButton,\n      payload: {\n        button,\n      },\n    });\n  };\n\n  return (\n    <div>\n      <div\n        css={css`\n          margin: 20px 0;\n        `}\n      >\n        <input\n          css={css`\n            border: solid 1px white;\n            background: transparent;\n            border-radius: 5px;\n            padding: 10px 20px;\n            color: white;\n            margin-bottom: 5px;\n            width: 250px;\n            max-width: 100%;\n            font-size: 16px;\n          `}\n          onChange={({ target }) => onChange(target.value)}\n          placeholder=\"Enter a decimal bitmask here\"\n        />\n        <div\n          css={css`\n            min-height: 21px;\n          `}\n        >\n          {error}\n        </div>\n      </div>\n      <div\n        css={css`\n          margin-bottom: 40px;\n        `}\n      >\n        <BitmaskDisplay mask={state.mask} />\n      </div>\n      <ControllerDisplay buttons={state.buttons} onClick={onButtonClick} />\n      <div\n        css={css`\n          font-size: 24px;\n          margin-top: 20px;\n          min-height: 32px;\n        `}\n      >\n        <OrderedButtonPreview value={state.buttons} />\n      </div>\n    </div>\n  );\n};\n","import \"./App.scss\";\n\nimport React from \"react\";\nimport { hot } from \"react-hot-loader/root\";\n\nimport { AppProvider } from \"./store\";\nimport { ButtonMaskInput } from \"./containers/ButtonMaskInput\";\n\nconst App: React.FC = () => {\n  return (\n    <AppProvider>\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>Slippi Bitmask Input Visualizer</h1>\n          <ButtonMaskInput />\n        </header>\n      </div>\n    </AppProvider>\n  );\n};\n\nexport default hot(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import \"./index.scss\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}